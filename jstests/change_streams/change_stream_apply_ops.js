// Tests that a change stream will correctly unwind applyOps entries generated by a transaction.
// @tags: [uses_transactions]

(function() {
    "use strict";

    load("jstests/libs/change_stream_util.js");
    load("jstests/libs/collection_drop_recreate.js");  // For assert[Drop|Create]Collection.

    let cst = new ChangeStreamTest(db);

    const collName = "change_stream_apply_ops";
    const otherCollName = "change_stream_apply_ops_2";
    const coll = assertDropAndRecreateCollection(db, collName);
    assertDropAndRecreateCollection(db, otherCollName);

    // Insert a document that gets deleted as part of the transaction.
    const kDeletedDocumentId = 0;
    db[collName].insert({_id: kDeletedDocumentId, a: "I was here before the transaction"});

    let aggcursor = cst.startWatchingChanges({pipeline: [{$changeStream: {}}], collection: coll});

    const sessionOptions = {causalConsistency: false};
    const session = db.getMongo().startSession(sessionOptions);
    const sessionDb = session.getDatabase(db.getName());

    session.startTransaction({readConcern: {level: "snapshot"}, writeConcern: {w: "majority"}});
    assert.commandWorked(sessionDb[collName].insert({_id: 1, a: 0}));
    assert.commandWorked(sessionDb[collName].insert({_id: 2, a: 0}));

    // One insert on a collection that we're not watching. This should be skipped in the change
    // stream.
    assert.commandWorked(sessionDb[otherCollName].insert({_id: 3, a: "SHOULD NOT READ THIS"}));

    assert.commandWorked(sessionDb[collName].updateOne({_id: 1}, {$inc: {a: 1}}));

    assert.commandWorked(sessionDb[collName].deleteOne({_id: kDeletedDocumentId}));

    session.commitTransaction();

    // Do applyOps on the collection that we care about. This is an "external" applyOps, though
    // (not run as part of a transaction) so its entries should be skipped in the change stream.
    assert.commandWorked(db.runCommand({
        applyOps: [
            {op: "i", ns: coll.getFullName(), o: {_id: 3, a: "SHOULD NOT READ THIS"}},
        ]
    }));

    // Drop the collection. This will trigger an "invalidate" event.
    assert.commandWorked(db.runCommand({drop: collName}));

    // Check for the first insert.
    let change = cst.getOneChange(aggcursor);
    assert.eq(change.fullDocument._id, 1);
    assert.eq(change.operationType, "insert", tojson(change));
    const firstChangeTxnNumber = change.txnNumber;
    const firstChangeLsid = change.lsid;
    assert.eq(typeof firstChangeLsid, "object");

    // Check for the second insert.
    change = cst.getOneChange(aggcursor);
    printjson(change);
    assert.eq(change.fullDocument._id, 2);
    assert.eq(change.operationType, "insert", tojson(change));
    assert.eq(firstChangeTxnNumber.valueOf(), change.txnNumber);
    assert.eq(0, bsonWoCompare(firstChangeLsid, change.lsid));

    // Check for the update.
    change = cst.getOneChange(aggcursor);
    printjson(change);
    assert.eq(tojson(change.updateDescription.updatedFields), tojson({"a": 1}));
    assert.eq(change.operationType, "update", tojson(change));
    assert.eq(firstChangeTxnNumber.valueOf(), change.txnNumber);
    assert.eq(0, bsonWoCompare(firstChangeLsid, change.lsid));

    // Check for the delete.
    change = cst.getOneChange(aggcursor);
    printjson(change);
    assert.eq(change.documentKey._id, kDeletedDocumentId);
    assert.eq(change.operationType, "delete", tojson(change));
    assert.eq(firstChangeTxnNumber.valueOf(), change.txnNumber);
    assert.eq(0, bsonWoCompare(firstChangeLsid, change.lsid));

    cst.assertNextChangesEqual({
        cursor: aggcursor,
        expectedChanges: [{operationType: "invalidate"}],
        expectInvalidate: true
    });

    cst.cleanUp();
}());
