// Tests that a change stream will correctly unwind applyOps entries generated by a transaction.
// @tags: [uses_transactions]

(function() {
    "use strict";

    load("jstests/libs/change_stream_util.js");
    load("jstests/libs/collection_drop_recreate.js");  // For assert[Drop|Create]Collection.

    var WatchMode = {
        kCollection: 1,
        kDb: 2,
        kCluster: 3,
    };

    function getChangeStream({cst, watchMode, coll, resumeToken}) {
        const changeStreamDoc = {};
        if (resumeToken) {
            changeStreamDoc.resumeAfter = resumeToken;
        }

        if (watchMode == WatchMode.kCluster) {
            changeStreamDoc.allChangesForCluster = true;
        }
        const collArg = (watchMode == WatchMode.kCollection ? coll : 1);

        return cst.startWatchingChanges({
            pipeline: [{$changeStream: changeStreamDoc}],
            collection: collArg,
            // Use a batch size of 0 to prevent any notifications from being returned in the first
            // batch. These would be ignored by ChangeStreamTest.getOneChange().
            aggregateOptions: {cursor: {batchSize: 0}},
        });
    }

    function testChangeStreamsWithTransactions(watchMode) {
        let dbToStartTestOn = db;
        if (watchMode == WatchMode.kCluster) {
            dbToStartTestOn = db.getSiblingDB("admin");
        }

        const coll = assertDropAndRecreateCollection(db, "change_stream_apply_ops");
        const otherCollName = "change_stream_apply_ops_2";
        assertDropAndRecreateCollection(db, otherCollName);

        const otherDbName = "change_stream_apply_ops_db";
        const otherDbCollName = "someColl";
        assertDropAndRecreateCollection(db.getSiblingDB(otherDbName), otherDbCollName);

        const cst = new ChangeStreamTest(dbToStartTestOn);

        let changeStream = getChangeStream({cst: cst, watchMode: watchMode, coll: coll});

        // Do an insert outside of a transaction.
        assert.commandWorked(coll.insert({_id: 0, a: 123}));
        const nonTxnChange = cst.getOneChange(changeStream);
        assert.eq(nonTxnChange.operationType, "insert");
        assert.eq(nonTxnChange.documentKey, {_id: 0});

        const sessionOptions = {causalConsistency: false};
        const session = db.getMongo().startSession(sessionOptions);
        const sessionDb = session.getDatabase(db.getName());
        const sessionColl = sessionDb[coll.getName()];

        session.startTransaction({readConcern: {level: "snapshot"}, writeConcern: {w: "majority"}});
        assert.commandWorked(sessionColl.insert({_id: 1, a: 0}));
        assert.commandWorked(sessionColl.insert({_id: 2, a: 0}));

        // One insert on a collection that we're not watching. This should be skipped by the
        // single-collection change stream.
        assert.commandWorked(
            sessionDb[otherCollName].insert({_id: 111, a: "Doc on other collection"}));

        // This should be skipped by the single-collection and single-db changestreams.
        assert.commandWorked(session.getDatabase(otherDbName)[otherDbCollName].insert(
            {_id: 222, a: "Doc on other DB"}));

        assert.commandWorked(sessionColl.updateOne({_id: 1}, {$inc: {a: 1}}));

        session.commitTransaction();

        // Now insert another document, not part of a transaction.
        assert.commandWorked(coll.insert({_id: 3, a: 123}));

        // Check for the first insert.
        const firstTxnChange = cst.getOneChange(changeStream);
        assert.eq(firstTxnChange.fullDocument._id, 1);
        assert.eq(firstTxnChange.operationType, "insert", tojson(firstTxnChange));

        // Check for the second insert.
        const secondTxnChange = cst.getOneChange(changeStream);
        assert.eq(secondTxnChange.fullDocument._id, 2);
        assert.eq(secondTxnChange.operationType, "insert", tojson(secondTxnChange));

        // Resume after the first non-transaction change. Be sure we see the documents from the
        // transaction again.
        changeStream = getChangeStream(
            {cst: cst, watchMode: watchMode, coll: coll, resumeToken: nonTxnChange._id});
        assert.docEq(cst.getOneChange(changeStream), firstTxnChange);
        assert.docEq(cst.getOneChange(changeStream), secondTxnChange);

        // Resume after the first transaction change. Be sure we see the second change again.
        changeStream = getChangeStream(
            {cst: cst, watchMode: watchMode, coll: coll, resumeToken: firstTxnChange._id});
        assert.docEq(cst.getOneChange(changeStream), secondTxnChange);

        let change = secondTxnChange;
        if (watchMode >= WatchMode.kDb) {
            // We should see the insert on the other collection.
            change = cst.getOneChange(changeStream);
            assert.eq(change.fullDocument._id, 111);
            assert.eq(change.operationType, "insert", tojson(change));

            // Resume from the beginning again, be sure we see everything up until now.
            changeStream = getChangeStream(
                {cst: cst, watchMode: watchMode, coll: coll, resumeToken: nonTxnChange._id});
            assert.docEq(cst.getOneChange(changeStream), firstTxnChange);
            assert.docEq(cst.getOneChange(changeStream), secondTxnChange);
            assert.docEq(cst.getOneChange(changeStream), change);
        }

        if (watchMode >= WatchMode.kCluster) {
            // We should see the insert on the other db.
            change = cst.getOneChange(changeStream);
            assert.eq(change.fullDocument._id, 222);
            assert.eq(change.operationType, "insert", tojson(change));

            // Resume from the beginning again, be sure we see everything up until now.
            changeStream = getChangeStream(
                {cst: cst, watchMode: watchMode, coll: coll, resumeToken: nonTxnChange._id});
            assert.docEq(cst.getOneChange(changeStream), firstTxnChange);
            assert.docEq(cst.getOneChange(changeStream), secondTxnChange);
            // We should see the document which was inserted on the other _collection_.
            const changeFromOtherCollection = cst.getOneChange(changeStream);
            assert.eq(changeFromOtherCollection.fullDocument._id, 111);

            // Resume from the document in the other collection.
            changeStream = getChangeStream({
                cst: cst,
                watchMode: watchMode,
                coll: coll,
                resumeToken: changeFromOtherCollection._id
            });

            // We should again see the most recent document.
            assert.docEq(cst.getOneChange(changeStream), change);
        }

        // Try starting another change stream from the latest change, the _last_ change caused by
        // the transaction.
        let otherCursor =
            getChangeStream({cst: cst, watchMode: watchMode, coll: coll, resumeToken: change._id});

        // Check for the update.
        change = cst.getOneChange(changeStream);
        assert.eq(change.operationType, "update", tojson(change));
        assert.eq(tojson(change.updateDescription.updatedFields), tojson({"a": 1}));

        // Check for the update on the other stream.
        assert.docEq(change, cst.getOneChange(otherCursor));

        // Now test that we can resume from the _last_ change caused by a transaction.  We will
        // check that both the initial change stream and the new one find the document that's
        // inserted outside of the transaction.
        otherCursor =
            getChangeStream({cst: cst, watchMode: watchMode, coll: coll, resumeToken: change._id});

        // Now check that the document inserted after the transaction is found.
        change = cst.getOneChange(changeStream);
        assert.eq(change.fullDocument._id, 3);
        assert.eq(change.operationType, "insert", tojson(change));
        assert.docEq(change, cst.getOneChange(otherCursor));

        // Drop the collection. This will trigger an "invalidate" event.
        assert.commandWorked(db.runCommand({drop: coll.getName()}));

        // The drop should have invalidated the change stream.
        cst.assertNextChangesEqual({
            cursor: changeStream,
            expectedChanges: [{operationType: "invalidate"}],
            expectInvalidate: true
        });

        cst.assertNextChangesEqual({
            cursor: otherCursor,
            expectedChanges: [{operationType: "invalidate"}],
            expectInvalidate: true
        });

        cst.cleanUp();
    }

    // TODO: SERVER-34302 should allow us to simplify this test, so we're not required to
    // explicitly run both against a single collection and against the whole DB.
    testChangeStreamsWithTransactions(WatchMode.kCollection);
    testChangeStreamsWithTransactions(WatchMode.kDb);
    testChangeStreamsWithTransactions(WatchMode.kCluster);
}());
