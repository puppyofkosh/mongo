// Tests that a change stream will correctly unwind applyOps entries generated by a transaction.
// @tags: [uses_transactions]

(function() {
    "use strict";

    load("jstests/libs/change_stream_util.js");
    load("jstests/libs/collection_drop_recreate.js");  // For assert[Drop|Create]Collection.

    var WatchMode = {
        kCollection: 1,
        kDb: 2,
        kCluster: 3,
    };

    function getChangeStream(cst, watchMode, coll, resumeToken) {
        const changeStreamDoc = {};
        if (resumeToken) {
            changeStreamDoc.resumeAfter = resumeToken;
        }

        if (watchMode == WatchMode.kCluster) {
            changeStreamDoc.allChangesForCluster = true;
        }
        const collArg = (watchMode == WatchMode.kCollection ? coll : 1);

        return cst.startWatchingChanges({
            pipeline: [{$changeStream: changeStreamDoc}],
            collection: collArg,
            aggregateOptions: {cursor: {batchSize: 0}}
        });
    }

    function testChangeStreamsWithTransactions(watchMode) {
        let dbToStartTestOn = db;
        if (watchMode == WatchMode.kCluster) {
            dbToStartTestOn = db.getSiblingDB("admin");
        }

        const otherCollName = "change_stream_apply_ops_2";
        const coll = assertDropAndRecreateCollection(db, "change_stream_apply_ops");
        assertDropAndRecreateCollection(db, otherCollName);

        const otherDbName = "change_stream_apply_ops_db";
        const otherDbCollName = "someColl";
        assertDropAndRecreateCollection(db.getSiblingDB(otherDbName), otherDbCollName);

        let cst = new ChangeStreamTest(dbToStartTestOn);

        let changeStream = getChangeStream(cst, watchMode, coll);

        // Do an insert outside of a transaction.
        assert.commandWorked(coll.insert({_id: 0, a: 123}));
        let nonTxnChange = cst.getOneChange(changeStream);

        const sessionOptions = {causalConsistency: false};
        const session = db.getMongo().startSession(sessionOptions);
        const sessionDb = session.getDatabase(db.getName());
        const sessionColl = sessionDb[coll.getName()];

        session.startTransaction({readConcern: {level: "snapshot"}, writeConcern: {w: "majority"}});
        assert.commandWorked(sessionColl.insert({_id: 1, a: 0}));
        assert.commandWorked(sessionColl.insert({_id: 2, a: 0}));

        // One insert on a collection that we're not watching. This should be skipped by the
        // single-collection changestream.
        assert.commandWorked(
            sessionDb[otherCollName].insert({_id: 111, a: "Doc on other collection"}));

        // This should be skipped by the single-collection and single-db changestreams.
        assert.commandWorked(session.getDatabase(otherDbName)[otherDbCollName].insert(
            {_id: 222, a: "Doc on other DB"}));

        assert.commandWorked(sessionColl.updateOne({_id: 1}, {$inc: {a: 1}}));

        session.commitTransaction();

        // Now insert another document, not part of a transaction.
        assert.commandWorked(coll.insert({_id: 3, a: 123}));

        // Check for the first insert.
        const firstChange = cst.getOneChange(changeStream);
        assert.eq(firstChange.fullDocument._id, 1);
        assert.eq(firstChange.operationType, "insert", tojson(firstChange));

        // Check for the second insert.
        const secondChange = cst.getOneChange(changeStream);
        assert.eq(secondChange.fullDocument._id, 2);
        assert.eq(secondChange.operationType, "insert", tojson(secondChange));

        // Resume after the first non-transaction change. Be sure we see the documents from the
        // transaction again.
        changeStream = getChangeStream(cst, watchMode, coll, nonTxnChange._id);
        // We should see the second change again.
        assert.docEq(cst.getOneChange(changeStream), firstChange);
        assert.docEq(cst.getOneChange(changeStream), secondChange);

        // Resume after the first transaction change. Be sure we see the second change again.
        changeStream = getChangeStream(cst, watchMode, coll, firstChange._id);
        assert.docEq(cst.getOneChange(changeStream), secondChange);

        let change = secondChange;
        if (watchMode >= WatchMode.kDb) {
            // We should see the insert on the other collection.
            change = cst.getOneChange(changeStream);
            assert.eq(change.fullDocument._id, 111);
            assert.eq(change.operationType, "insert", tojson(change));

            // Resume from the beginning again, be sure we see everything up until now.
            changeStream = getChangeStream(cst, watchMode, coll, firstChange._id);
            assert.docEq(cst.getOneChange(changeStream), secondChange);
            assert.docEq(cst.getOneChange(changeStream), change);
        }

        if (watchMode >= WatchMode.kCluster) {
            // We should see the insert on the other db.
            change = cst.getOneChange(changeStream);
            assert.eq(change.fullDocument._id, 222);
            assert.eq(change.operationType, "insert", tojson(change));

            // Resume from the beginning again, be sure we see everything up until now.
            changeStream = getChangeStream(cst, watchMode, coll, firstChange._id);
            assert.docEq(cst.getOneChange(changeStream), secondChange);
            // We should see the document which was inserted on the other _collection_.
            assert.eq(cst.getOneChange(changeStream).fullDocument._id, 111);
            // We should again see the most recent document.
            assert.docEq(cst.getOneChange(changeStream), change);
        }

        // Try starting another change stream from the latest change.
        let otherCursor = getChangeStream(cst, watchMode, coll, change._id);

        // Check for the update.
        change = cst.getOneChange(changeStream);
        assert.eq(change.operationType, "update", tojson(change));
        assert.eq(tojson(change.updateDescription.updatedFields), tojson({"a": 1}));

        // Check for the update on the other stream.
        assert.docEq(change, cst.getOneChange(otherCursor));

        // Now test that we can resume from the _last_ change caused by a transaction.  We will
        // check that both the initial change stream and the new one find the document that's
        // inserted outside of the transaction.
        otherCursor = getChangeStream(cst, watchMode, coll, change._id);

        // Now check that the document inserted after the transactioni s found.
        change = cst.getOneChange(changeStream);
        assert.eq(change.fullDocument._id, 3);
        assert.eq(change.operationType, "insert", tojson(change));
        assert.docEq(change, cst.getOneChange(otherCursor));

        // Drop the collection. This will trigger an "invalidate" event.
        assert.commandWorked(db.runCommand({drop: coll.getName()}));

        // The drop should have invalidated the change stream.
        cst.assertNextChangesEqual({
            cursor: changeStream,
            expectedChanges: [{operationType: "invalidate"}],
            expectInvalidate: true
        });

        cst.assertNextChangesEqual({
            cursor: otherCursor,
            expectedChanges: [{operationType: "invalidate"}],
            expectInvalidate: true
        });

        cst.cleanUp();
    }

    // TODO: SERVER-34302 should allow us to simplify this test, so we're not required to
    // explicitly run both against a single collection and against the whole DB.
    testChangeStreamsWithTransactions(WatchMode.kCollection);
    testChangeStreamsWithTransactions(WatchMode.kDb);
    testChangeStreamsWithTransactions(WatchMode.kCluster);
}());
